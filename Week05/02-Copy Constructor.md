# üéì Copy Constructor, Shallow Copy, and Deep Copy in C++

## üéØ Learning Objectives

By the end of this lecture, students will be able to:

- Define and explain the purpose of the **copy constructor**  
- Differentiate between **shallow copy** and **deep copy**  
- Recognize when the **default copy constructor is insufficient**  
- Write **custom copy constructors** for deep copying

---

## üìå 1. What Is a Copy Constructor?

A **copy constructor** is a **special constructor** used to create a new object as a **copy of an existing object**.

It is invoked:

- When an object is **initialized** with another object of the same class
- When an object is **passed by value** to a function
- When an object is **returned by value**

---

### üîπ Syntax:

```cpp
ClassName(const ClassName &other);
```
### üî∏ Purpose of Copy Constructor:

Used to **copy data** from one object to another during:

- ‚úÖ Object initialization: `Class obj2 = obj1;`
- ‚úÖ Passing an object by value to a function
- ‚úÖ Returning an object from a function by value

---

## üß± 2. Example: Default Copy Constructor

```cpp
class Student {
public:
    string name;
    int rollNo;
};

int main() {
    Student s1 = {"Ali", 101};
    Student s2 = s1;  // Default copy constructor is called
}
```
> ‚ÑπÔ∏è This is a **shallow copy**, automatically generated by the **compiler**.  
> It copies **each data member** bit-by-bit, which works fine for simple types,  
> but can lead to issues with **pointers or dynamically allocated memory**.
## üîÑ 3. Shallow Copy vs Deep Copy

| Feature        | Shallow Copy                                | Deep Copy                                   |
|----------------|----------------------------------------------|----------------------------------------------|
| **Copies**      | Member-wise (only pointer values copied)     | Actual memory/content pointed to is copied   |
| **Affects same data?** | ‚úÖ Yes ‚Äî shared memory between objects | ‚ùå No ‚Äî creates independent memory copies     |
| **Risk**        | Dangling pointers, double deletion, memory bugs | Safe and stable                              |
| **Use case**    | Safe for simple (non-pointer) types          | Required for dynamic memory (e.g., `new`)    |

---

### üîπ Shallow Copy Example (Problem Case)

```cpp
class Box {
    int* length;

public:
    Box(int l) {
        length = new int(l);
    }

    void display() {
        cout << "Length: " << *length << endl;
    }

    ~Box() {
        delete length;
    }
};

int main() {
    Box b1(10);
    Box b2 = b1;  // ‚ùå Default copy ‚Üí shallow copy ‚Üí both point to same memory
}
```
> ‚ö†Ô∏è **Both `b1` and `b2` share the same pointer**, because only the pointer value (address) is copied.  
> When the **destructor** is called for both objects, it tries to **delete the same memory twice**,  
> leading to a **crash or undefined behavior** (double deletion).
### üî∏ Deep Copy Example (Custom Copy Constructor)

```cpp
class Box {
    int* length;

public:
    Box(int l) {
        length = new int(l);
    }

    // Custom copy constructor for deep copy
    Box(const Box &b) {
        length = new int(*b.length);  // Allocate new memory and copy the value
    }

    void display() {
        cout << "Length: " << *length << endl;
    }

    ~Box() {
        delete length;
    }
};
```
> ‚úÖ Now `b1` and `b2` have **separate memory locations** for `length`.  
> Each object manages its own memory, so when their destructors run,  
> they safely deallocate **only their own** memory ‚Äî no conflicts or crashes.
## üí° 4. When Is a Deep Copy Needed?

A **deep copy** is required:

- ‚úÖ When the class uses **dynamic memory allocation** (e.g., using `new`)  
- ‚úÖ When data is stored in **pointers, arrays, or linked structures**  
- ‚úÖ To avoid **shared state** between objects that leads to **memory corruption**  
- ‚úÖ When multiple objects should operate on **independent copies** of the same data

---

## üß† 5. Copy Constructor vs Assignment Operator

| Feature              | Copy Constructor                       | Assignment Operator                 |
|----------------------|-----------------------------------------|-------------------------------------|
| **Called when**      | A **new object is created** from another | An **existing object is assigned** another |
| **Syntax**           | `ClassName(const ClassName&)`           | `operator=` function                |
| **Implicitly provided?** | ‚úÖ Yes                              | ‚úÖ Yes                              |

> üìå Both are important for **safe object copying**, but are used in **different scenarios**.  
> You may need to **customize both** when your class handles **dynamic memory**.
